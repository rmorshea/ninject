{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>PyBooster is a dependency injection framework for Python that reduces boilerplate by leveraging modern typing features.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -U pybooster\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Getting started with PyBooster involves a few steps:</p> <ol> <li>Define a provider function for a    dependency.</li> <li>Add an injector to a function that will use that dependency.</li> <li>Activate the provider's scope and call injected    function inside it.</li> </ol> <p>Here's brief example showing how to inject a <code>sqlite3.Connection</code> object into a function that executes a query:</p> <pre><code>import sqlite3\nfrom typing import Iterator\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@provider.iterator\ndef sqlite_connection(database: str) -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(database) as conn:\n        yield conn\n\n\n@injector.function\ndef query_database(query: str, *, conn: sqlite3.Connection = required) -&gt; None:\n    conn.execute(query)\n\n\nwith sqlite_connection.scope(\":memory:\"):\n    query_database(\"CREATE TABLE example (id INTEGER PRIMARY KEY)\")\n</code></pre>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#injectors","title":"Injectors","text":"<p>Injectors are used to supply a set of dependencies to a function or context.</p>"},{"location":"concepts/#decorator-injectors","title":"Decorator Injectors","text":"<p>PyBooster supplies a set of decorators that can be added to functions in order to inject dependencies. Dependencies for a decorated function are declared as keyword-only arguments with a type annotation and a default value of <code>required</code>.</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import required\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@injector.function\ndef hello_greeting(*, recipient: Recipient = required) -&gt; str:\n    return f\"Hello, {recipient}!\"\n</code></pre> <p>Note</p> <p>Don't forget to add the <code>required</code> default value. Without it, PyBooster will not know that the argument is a dependency that needs to be injected.</p> <p>In order for a value to be injected you'll need to declare a provider and activate it:</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@injector.function\ndef hello_greeting(*, recipient: Recipient = required) -&gt; str:\n    return f\"Hello, {recipient}!\"\n\n\n@provider.function\ndef alice() -&gt; Recipient:\n    return Recipient(\"Alice\")\n\n\nwith alice.scope():\n    assert hello_greeting() == \"Hello, Alice!\"\n</code></pre> <p>PyBooster supports decorators for the following types of functions:</p> <ul> <li><code>injector.function</code></li> <li><code>injector.asyncfunction</code></li> <li><code>injector.iterator</code></li> <li><code>injector.asynciterator</code></li> <li><code>injector.contextmanager</code></li> <li><code>injector.asynccontextmanager</code></li> </ul> <p>You can use all of these decorators on methods of a class as well.</p> <p>Note</p> <p>You can always skip injecting a dependency by passing a value directly as an argument:</p> <p><code>python test=\"false\" assert hello_greeting(recipient=\"Bob\") == \"Hello, Bob!\"</code></p> <p>This will not trigger the provider for <code>Recipient</code> and will use the value passed to the function instead. Doing so can be useful for re-using a dependency across multiple function calls without the indirection created by establishing a <code>shared</code> context.</p>"},{"location":"concepts/#inline-injector","title":"Inline Injector","text":"<p>If you need to access the current value of a dependency outside of a function, you can use <code>injector.current</code> by activating it either as a synchronous or asynchronous context manager.</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@provider.function\ndef alice() -&gt; Recipient:\n    return Recipient(\"Alice\")\n\n\nwith alice.scope(), injector.current(Recipient) as recipient:\n    assert recipient == \"Alice\"\n</code></pre>"},{"location":"concepts/#providers","title":"Providers","text":"<p>A provider is a function that creates or yields a dependency. Providers are used to define how dependencies resolved when they are injected into a function or context. What providers are available depends on what scopes are active when a dependency is resolved.</p>"},{"location":"concepts/#defining-sync-providers","title":"Defining Sync Providers","text":"<p>Sync providers can either be functions the return a dependency's value:</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import provider\n\n\n@dataclass\nclass Config:\n    username: str\n    password: str\n\n\n@provider.function\ndef config() -&gt; Config:\n    return Config(username=\"alice\", password=\"EGwVEo3y9E\")\n</code></pre> <p>Or iterators that yield the dependency's value. Iterators are useful when you have resources that need to be cleaned up when the dependency's value is no longer in use.</p> <pre><code>import sqlite3\nfrom typing import Iterator\n\nfrom pybooster import provider\n\n\n@provider.iterator\ndef sqlite_connection() -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(\"example.db\") as conn:\n        yield conn\n</code></pre>"},{"location":"concepts/#defining-async-providers","title":"Defining Async Providers","text":"<p>Async providers can either be a coroutine function that returns a dependency's value:</p> <pre><code>from asyncio import sleep\nfrom dataclasses import dataclass\n\nfrom pybooster import provider\n\n\n@dataclass\nclass Config:\n    username: str\n    password: str\n\n\n@provider.asyncfunction\nasync def async_config() -&gt; Config:\n    await sleep(1)  # Do some async work here...\n    return Config(username=\"alice\", password=\"EGwVEo3y9E\")\n</code></pre> <p>Or async iterators that yield the dependency's value. Async iterators are useful when you have resources that need to be cleaned up when the dependency's value is no longer in use.</p> <pre><code>from asyncio import StreamReader\nfrom asyncio import open_connection\nfrom typing import AsyncIterator\n\nfrom pybooster import provider\n\n\n@provider.asynciterator\nasync def example_reader() -&gt; AsyncIterator[StreamReader]:\n    reader, writer = await open_connection(\"example.com\", 80)\n    writer.write(b\"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\")\n    await writer.drain()\n    try:\n        yield reader\n    finally:\n        writer.close()\n        await writer.wait_closed()\n</code></pre>"},{"location":"concepts/#mixing-syncasync-providers","title":"Mixing Sync/Async Providers","text":"<p>You can define both sync and async providers for the same dependency. Sync providers can be used in async contexts, but not the other way around. PyBooster will always choose to use an async provider when running in an async context and one is available.</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@dataclass\nclass Config:\n    username: str\n    password: str\n\n\n@provider.function\ndef config() -&gt; Config:\n    return Config(username=\"sync-user\", password=\"sync-pass\")\n\n\n@provider.asyncfunction\nasync def async_config() -&gt; Config:\n    await asyncio.sleep(0)  # Do some async work here...\n    return Config(username=\"async-user\", password=\"async-pass\")\n\n\n@injector.function\ndef get_config(*, config: Config = required) -&gt; str:\n    return f\"{config.username}:{config.password}\"\n\n\n@injector.asyncfunction\nasync def get_async_config(*, config: Config = required) -&gt; str:\n    return f\"{config.username}:{config.password}\"\n\n\nwith config.scope(), async_config.scope():\n    assert get_config() == \"sync-user:sync-pass\"\n    assert asyncio.run(get_async_config()) == \"async-user:async-pass\"\n\nwith config.scope():\n    assert asyncio.run(get_async_config()) == \"sync-user:sync-pass\"\n</code></pre>"},{"location":"concepts/#parameterizing-providers","title":"Parameterizing Providers","text":"<p>You can pass additional arguments to a provider by adding parameters to a provider function signature that are not dependencies:</p> <pre><code>import sqlite3\nfrom typing import Iterator\n\nfrom pybooster import provider\n\n\n@provider.iterator\ndef sqlite_connection(database: str) -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(database) as conn:\n        yield conn\n</code></pre> <p>These parameters can be supplied when activating the <code>scope</code>.</p> <p>```python test=\"false\" with sqlite_connection.scope(\":memory:\"):     ... <pre><code>You can also declare these parameters as dependencies by making them keyword-only,\nannotating them with the desired type, and setting the default value to `required`.\n\n```python\nimport os\nimport sqlite3\nfrom typing import Iterator\nfrom typing import NewType\n\nfrom pybooster import provider\nfrom pybooster import required\n\nDatabase = NewType(\"DatabasePath\", str)\n\n\n@provider.function\ndef sqlite_database() -&gt; Database:\n    return Database(os.environ.get(\"SQLITE_DATABASE\", \":memory:\"))\n\n\n@provider.iterator\ndef sqlite_connection(*, database: Database = required) -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(database) as conn:\n        yield conn\n</code></pre></p>"},{"location":"concepts/#scoping-providers","title":"Scoping Providers","text":"<p>What providers are available to inject dependencies is determined by what scopes are active when the dependency is resolved. Scopes can be activated using the <code>scope</code> method of a provider.</p> <pre><code>from typing import NewType\n\nfrom pybooster import provider\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@provider.function\ndef alice() -&gt; Recipient:\n    return Recipient(\"Alice\")\n\n\nwith alice.scope():\n    ...  # alice is available to inject\n</code></pre> <p>You can override a dependency's provider by activating a new scope for the same dependency.</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@provider.function\ndef alice() -&gt; Recipient:\n    return Recipient(\"Alice\")\n\n\n@provider.function\ndef bob() -&gt; Recipient:\n    return Recipient(\"Bob\")\n\n\n@injector.function\ndef get_recipient(*, recipient: Recipient = required) -&gt; str:\n    return recipient\n\n\nwith alice.scope():\n    assert get_recipient() == \"Alice\"\n    with bob.scope():\n        assert get_recipient() == \"Bob\"\n    assert get_recipient() == \"Alice\"\n</code></pre> <p>Note</p> <p>The exact behavior of scopes can depend on whether the requested dependency is a union or has subclasses.</p>"},{"location":"concepts/#dependencies","title":"Dependencies","text":"<p>A dependency is (almost) any Python type or class.</p>"},{"location":"concepts/#built-in-types","title":"Built-In Types","text":"<p>PyBooster does not allow you to use built-in types directly. Instead you should use <code>NewType</code> to define a distinct subtype so that it is easily identifiable. For example, instead of using <code>str</code> to represent a username, you might define a <code>Username</code> new type like this:</p> <pre><code>from typing import NewType\n\nUsername = NewType(\"Username\", str)\n</code></pre> <p>Now you can make a provider for <code>Username</code> and inject it into functions.</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\nUsername = NewType(\"Username\", str)\n\n\n@provider.function\ndef username() -&gt; Username:\n    return \"alice\"\n\n\n@injector.function\ndef greeting(*, username: Username = required) -&gt; str:\n    return f\"Hello, {username}!\"\n\n\nwith username.scope():\n    assert greeting() == \"Hello, alice!\"\n</code></pre>"},{"location":"concepts/#user-defined-types","title":"User-Defined Types","text":"<p>This includes types you or a third-party package define. In this case, an <code>Auth</code> class:</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@dataclass\nclass Auth:\n    role: str\n    username: str\n    password: str\n\n\n@provider.function\ndef auth() -&gt; Auth:\n    return Auth(role=\"user\", username=\"alice\", password=\"EGwVEo3y9E\")\n\n\n@injector.function\ndef login_message(*, auth: Auth = required) -&gt; str:\n    return f\"Logged in as {auth.username}\"\n\n\nwith auth.scope():\n    assert login_message() == \"Logged in as alice\"\n</code></pre>"},{"location":"concepts/#subclassed-types","title":"Subclassed Types","text":"<p>Providers of subclasses will be automatically injected into functions that require the base class. So an <code>AdminAuth</code> class that extends <code>Auth</code> will be injected into functions that require <code>Auth</code>.</p> <pre><code>from dataclasses import dataclass\nfrom typing import Literal\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@dataclass\nclass Auth:\n    role: str\n    username: str\n    password: str\n\n\n@dataclass\nclass AdminAuth(Auth):\n    role: Literal[\"admin\"]\n\n\n@provider.function\ndef admin_auth() -&gt; AdminAuth:\n    return AdminAuth(role=\"admin\", username=\"admin\", password=\"admin\")\n\n\n@injector.function\ndef login_message(*, auth: Auth = required) -&gt; str:\n    return f\"Logged in as {auth.username}\"\n\n\nwith admin_auth.scope():\n    assert login_message() == \"Logged in as admin\"\n</code></pre>"},{"location":"concepts/#union-types","title":"Union Types","text":"<p>You can require a union of types by using the <code>Union</code> type or the <code>|</code> operator (where supported). Doing so will resolve the first dependency that has a provider available in the order declared by the union (left-to-right). This could be useful in case, as below, where you have an <code>Employee</code> or <code>Contractor</code> class that are not related by inheritance.</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@dataclass\nclass Employee:\n    name: str\n    employee_id: int\n\n\n@dataclass\nclass Contractor:\n    name: str\n    contractor_id: int\n\n\n@provider.function\ndef employee() -&gt; Employee:\n    return Employee(name=\"Alice\", employee_id=1)\n\n\n@provider.function\ndef contractor() -&gt; Contractor:\n    return Contractor(name=\"Bob\", contractor_id=2)\n\n\n@injector.function\ndef greet(*, person: Employee | Contractor = required) -&gt; str:\n    return f\"Hello, {person.name}!\"\n\n\nwith employee.scope():\n    assert greet() == \"Hello, Alice!\"\n\nwith contractor.scope():\n    assert greet() == \"Hello, Bob!\"\n\nwith employee.scope(), contractor.scope():\n    assert greet() == \"Hello, Alice!\"\n</code></pre>"},{"location":"concepts/#tuple-types","title":"Tuple Types","text":"<p>You can provide a tuple of types from a provider in order to provide multiple dependencies at once. This is useful in async or threaded providers when it would be more efficient to gather dependencies in parallel. Or, as in the case below, if you need to destructure some data into separate dependencies.</p> <pre><code>import json\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\nUsername = NewType(\"Username\", str)\nPassword = NewType(\"Password\", str)\n\ntempfile = NamedTemporaryFile()\nSECRETS_JSON = Path(tempfile.name)\nSECRETS_JSON.write_text('{\"username\": \"alice\", \"password\": \"EGwVEo3y9E\"}')\n\n\n@provider.function\ndef username_and_password() -&gt; tuple[Username, Password]:\n    with SECRETS_JSON.open() as f:\n        secrets = json.load(f)\n    return Username(secrets[\"username\"]), Password(secrets[\"password\"])\n\n\n@injector.function\ndef login_message(*, username: Username = required) -&gt; str:\n    return f\"Logged in as {username}\"\n\n\nwith username_and_password.scope():\n    assert login_message() == \"Logged in as alice\"\n</code></pre>"},{"location":"concepts/#shared-contexts","title":"Shared Contexts","text":"<p>By default, PyBooster will create a new instance of a dependency each time it is injected. To change this, using the <code>shared</code> context manager to declare that a dependency should be re-used across all injections for the duration of a context. This will immediately execute the provider and store the result for future use.</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import shared\n\n\n@dataclass\nclass Auth:\n    username: str\n    password: str\n\n\n@provider.function\ndef auth() -&gt; Auth:\n    return Auth(username=\"alice\", password=\"EGwVEo3y9E\")\n\n\n@injector.function\ndef get_auth(*, auth: Auth = required) -&gt; Auth:\n    return auth\n\n\nwith auth.scope():\n\n    assert get_auth() is not get_auth()\n\n    with shared(Auth):\n        assert get_auth() is get_auth()\n</code></pre> <p>If the dependency's provider might be asynchronous, enter the <code>shared()</code> context manager using <code>async with</code> instead. If you in an async context you should default to using <code>async with</code> to ensure that async providers can be executed successfully.</p>"},{"location":"concepts/#shared-static-values","title":"Shared Static Values","text":"<p>You can share a static value across all injections by passing a <code>value</code> argument to the <code>shared</code> context manager. This can be useful for sharing configuration values or other static data.</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import required\nfrom pybooster import shared\n\n\n@dataclass\nclass Auth:\n    username: str\n    password: str\n\n\n@injector.function\ndef get_auth(*, auth: Auth = required) -&gt; Auth:\n    return auth\n\n\nwith shared(Auth, value=Auth(username=\"alice\", password=\"EGwVEo3y9E\")):\n    assert get_auth() is get_auth()\n</code></pre> <p>Note</p> <p>You do not need to declare a provider for a dependency that is shared in this way.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#sqlite","title":"SQLite","text":"<pre><code>import sqlite3\nfrom typing import Iterator\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@provider.iterator\ndef sqlite_connection(database: str) -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(database) as conn:\n        yield conn\n\n\n@injector.function\ndef query_database(query: str, *, conn: sqlite3.Connection = required) -&gt; None:\n    conn.execute(query)\n\n\nwith sqlite_connection.scope(\":memory:\"):\n    query_database(\"CREATE TABLE example (id INTEGER PRIMARY KEY)\")\n</code></pre>"},{"location":"examples/#sqlalchemy","title":"SQLAlchemy","text":"<pre><code>from collections.abc import Iterator\n\nfrom sqlalchemy import Engine\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.orm import mapped_column\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import shared\n\n\nclass Base(DeclarativeBase): ...\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n\n@provider.iterator\ndef sqlalchemy_engine(url: str) -&gt; Iterator[Engine]:\n    engine = create_engine(url)\n    try:\n        yield engine\n    finally:\n        engine.dispose()\n\n\n@provider.iterator\ndef sqlalchemy_session(*, engine: Engine = required) -&gt; Iterator[Session]:\n    with Session(bind=engine, expire_on_commit=False) as session, session.begin():\n        yield session\n\n\n@injector.function\ndef create_tables(*, session: Session = required) -&gt; None:\n    Base.metadata.create_all(session.bind)\n\n\n@injector.function\ndef add_user(name: str, *, session: Session = required) -&gt; int:\n    user = User(name=name)\n    session.add(user)\n    session.flush()\n    return user.id\n\n\n@injector.function\ndef get_user(user_id: int, *, session: Session = required) -&gt; User:\n    return session.execute(select(User).where(User.id == user_id)).scalar_one()\n\n\nurl = \"sqlite:///:memory:\"\nwith (\n    sqlalchemy_engine.scope(url),\n    sqlalchemy_session.scope(),\n    shared(Engine),\n):\n    create_tables()\n    user_id = add_user(\"Alice\")\n    user = get_user(user_id)\n    assert user.name == \"Alice\"\n</code></pre>"},{"location":"examples/#sqlalchemy-async","title":"SQLAlchemy (Async)","text":"<pre><code>import asyncio\nfrom collections.abc import AsyncIterator\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import shared\n\n\nclass Base(DeclarativeBase): ...\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n\n@provider.asynciterator\nasync def sqlalchemy_async_engine(url: str) -&gt; AsyncIterator[AsyncEngine]:\n    engine = create_async_engine(url)\n    try:\n        yield engine\n    finally:\n        await engine.dispose()\n\n\n@provider.asynciterator\nasync def sqlalchemy_async_session(\n    *, engine: AsyncEngine = required\n) -&gt; AsyncIterator[AsyncSession]:\n    async with (\n        AsyncSession(bind=engine, expire_on_commit=False) as session,\n        session.begin(),\n    ):\n        yield session\n\n\n@injector.asyncfunction\nasync def create_tables(*, engine: AsyncEngine = required) -&gt; None:\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n\n@injector.asyncfunction\nasync def add_user(name: str, *, session: AsyncSession = required) -&gt; int:\n    user = User(name=name)\n    session.add(user)\n    await session.flush()\n    return user.id\n\n\n@injector.asyncfunction\nasync def get_user(user_id: int, *, session: AsyncSession = required) -&gt; User:\n    return (await session.execute(select(User).where(User.id == user_id))).scalar_one()\n\n\nasync def main():\n    url = \"sqlite+aiosqlite:///:memory:\"\n    with sqlalchemy_async_engine.scope(url), sqlalchemy_async_session.scope():\n        async with shared(AsyncEngine):\n            await create_tables()\n            user_id = await add_user(\"Alice\")\n            user = await get_user(user_id)\n            assert user.name == \"Alice\"\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#pybooster","title":"pybooster","text":""},{"location":"reference/#pybooster.required","title":"pybooster.required","text":"<pre><code>required = make_sentinel_value(__name__, 'required')\n</code></pre> <p>A sentinel object used to indicate that a dependency is required.</p>"},{"location":"reference/#pybooster.injector","title":"pybooster.injector","text":""},{"location":"reference/#pybooster.injector.asynccontextmanager","title":"pybooster.injector.asynccontextmanager","text":"<pre><code>asynccontextmanager(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; Callable[P, AbstractAsyncContextManager[R]]\n</code></pre> <p>Inject dependencies into the given async context manager function.</p> Source code in <code>src/pybooster/injector.py</code> <pre><code>@paramorator\ndef asynccontextmanager(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; Callable[P, AbstractAsyncContextManager[R]]:\n    \"\"\"Inject dependencies into the given async context manager function.\"\"\"\n    return _asynccontextmanager(asynciterator(func, dependencies=dependencies))\n</code></pre>"},{"location":"reference/#pybooster.injector.asyncfunction","title":"pybooster.injector.asyncfunction","text":"<pre><code>asyncfunction(\n    func: Callable[P, Coroutine[Any, Any, R]],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; Callable[P, Coroutine[Any, Any, R]]\n</code></pre> <p>Inject dependencies into the given coroutine.</p> Source code in <code>src/pybooster/injector.py</code> <pre><code>@paramorator\ndef asyncfunction(\n    func: Callable[P, Coroutine[Any, Any, R]],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; Callable[P, Coroutine[Any, Any, R]]:\n    \"\"\"Inject dependencies into the given coroutine.\"\"\"\n    dependencies = get_callable_dependencies(func, dependencies)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:  # type: ignore[reportReturnType]\n        if not (missing := setdefault_arguments_with_initialized_dependencies(kwargs, dependencies)):\n            return await func(*args, **kwargs)\n        async with AsyncExitStack() as stack:\n            await async_update_arguments_by_initializing_dependencies(stack, kwargs, missing)\n            return await func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.injector.asynciterator","title":"pybooster.injector.asynciterator","text":"<pre><code>asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; AsyncIteratorCallable[P, R]\n</code></pre> <p>Inject dependencies into the given async iterator.</p> Source code in <code>src/pybooster/injector.py</code> <pre><code>@paramorator\ndef asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; AsyncIteratorCallable[P, R]:\n    \"\"\"Inject dependencies into the given async iterator.\"\"\"\n    dependencies = get_callable_dependencies(func, dependencies)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; AsyncIterator[R]:\n        if not (missing := setdefault_arguments_with_initialized_dependencies(kwargs, dependencies)):\n            async for value in func(*args, **kwargs):\n                yield value\n            return\n        async with AsyncExitStack() as stack:\n            await async_update_arguments_by_initializing_dependencies(stack, kwargs, missing)\n            async for value in func(*args, **kwargs):\n                yield value\n            return\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.injector.contextmanager","title":"pybooster.injector.contextmanager","text":"<pre><code>contextmanager(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; Callable[P, AbstractContextManager[R]]\n</code></pre> <p>Inject dependencies into the given context manager function.</p> Source code in <code>src/pybooster/injector.py</code> <pre><code>@paramorator\ndef contextmanager(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; Callable[P, AbstractContextManager[R]]:\n    \"\"\"Inject dependencies into the given context manager function.\"\"\"\n    return _contextmanager(iterator(func, dependencies=dependencies))\n</code></pre>"},{"location":"reference/#pybooster.injector.current","title":"pybooster.injector.current","text":"<pre><code>current(cls: type[R]) -&gt; _CurrentContext[R]\n</code></pre> <p>Get the current value of a dependency.</p> Source code in <code>src/pybooster/injector.py</code> <pre><code>def current(cls: type[R]) -&gt; _CurrentContext[R]:\n    \"\"\"Get the current value of a dependency.\"\"\"\n    return _CurrentContext(normalize_dependency(cls))\n</code></pre>"},{"location":"reference/#pybooster.injector.function","title":"pybooster.injector.function","text":"<pre><code>function(\n    func: Callable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; Callable[P, R]\n</code></pre> <p>Inject dependencies into the given function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to inject dependencies into.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies to inject into the function.</p> <code>None</code> Source code in <code>src/pybooster/injector.py</code> <pre><code>@paramorator\ndef function(\n    func: Callable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; Callable[P, R]:\n    \"\"\"Inject dependencies into the given function.\n\n    Args:\n        func: The function to inject dependencies into.\n        dependencies: The dependencies to inject into the function.\n    \"\"\"\n    dependencies = get_callable_dependencies(func, dependencies)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n        if not (missing := setdefault_arguments_with_initialized_dependencies(kwargs, dependencies)):\n            return func(*args, **kwargs)\n        with ExitStack() as stack:\n            sync_update_arguments_by_initializing_dependencies(stack, kwargs, missing)\n            return func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.injector.iterator","title":"pybooster.injector.iterator","text":"<pre><code>iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; IteratorCallable[P, R]\n</code></pre> <p>Inject dependencies into the given iterator.</p> Source code in <code>src/pybooster/injector.py</code> <pre><code>@paramorator\ndef iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; IteratorCallable[P, R]:\n    \"\"\"Inject dependencies into the given iterator.\"\"\"\n    dependencies = get_callable_dependencies(func, dependencies)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Iterator[R]:\n        try:\n            if not (missing := setdefault_arguments_with_initialized_dependencies(kwargs, dependencies)):\n                yield from func(*args, **kwargs)\n                return\n            with ExitStack() as stack:\n                sync_update_arguments_by_initializing_dependencies(stack, kwargs, missing)\n                yield from func(*args, **kwargs)\n                return\n        except StopIteration as e:\n            return e.value  # noqa: B901\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.provider","title":"pybooster.provider","text":""},{"location":"reference/#pybooster.provider.Provider","title":"pybooster.provider.Provider","text":"<pre><code>Provider: TypeAlias = (\n    \"SyncProvider[P, R] | AsyncProvider[P, R]\"\n)\n</code></pre> <p>A provider that produces a dependency.</p>"},{"location":"reference/#pybooster.provider.AsyncProvider","title":"pybooster.provider.AsyncProvider","text":"<pre><code>AsyncProvider(\n    manager: AsyncContextManagerCallable[P, R],\n    provides: type[R],\n    dependency_set: set[Sequence[type]],\n)\n</code></pre> <p>               Bases: <code>_Provider[P]</code>, <code>Generic[P, R]</code></p> <p>A provider that produces an async dependency.</p> Source code in <code>src/pybooster/provider.py</code> <pre><code>def __init__(\n    self,\n    manager: AsyncContextManagerCallable[P, R],\n    provides: type[R],\n    dependency_set: set[Sequence[type]],\n) -&gt; None:\n    self.provides = provides\n    self.value: AsyncContextManagerCallable[P, R] = manager\n    self._dependency_set = dependency_set\n    self._sync: Literal[False] = False\n</code></pre>"},{"location":"reference/#pybooster.provider.SyncProvider","title":"pybooster.provider.SyncProvider","text":"<pre><code>SyncProvider(\n    manager: ContextManagerCallable[P, R],\n    provides: type[R],\n    dependency_set: set[Sequence[type]],\n)\n</code></pre> <p>               Bases: <code>_Provider[P]</code>, <code>Generic[P, R]</code></p> <p>A provider that produces a dependency.</p> Source code in <code>src/pybooster/provider.py</code> <pre><code>def __init__(\n    self,\n    manager: ContextManagerCallable[P, R],\n    provides: type[R],\n    dependency_set: set[Sequence[type]],\n) -&gt; None:\n    self.provides = provides\n    self.value: ContextManagerCallable[P, R] = manager\n    self._dependency_set = dependency_set\n    self._sync: Literal[True] = True\n</code></pre>"},{"location":"reference/#pybooster.provider.asyncfunction","title":"pybooster.provider.asyncfunction","text":"<pre><code>asyncfunction(\n    func: Callable[P, Awaitable[R]],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | None = None\n) -&gt; AsyncProvider[P, R]\n</code></pre> <p>Create a provider from the given coroutine.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, Awaitable[R]]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/provider.py</code> <pre><code>@paramorator\ndef asyncfunction(\n    func: Callable[P, Awaitable[R]],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | None = None,\n) -&gt; AsyncProvider[P, R]:\n    \"\"\"Create a provider from the given coroutine.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_coroutine_return_type(func)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; AsyncIterator[R]:\n        yield await func(*args, **kwargs)\n\n    return asynciterator(wrapper, provides=provides, dependencies=dependencies)\n</code></pre>"},{"location":"reference/#pybooster.provider.asynciterator","title":"pybooster.provider.asynciterator","text":"<pre><code>asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | None = None\n) -&gt; AsyncProvider[P, R]\n</code></pre> <p>Create a provider from the given async iterator function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>AsyncIteratorCallable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/provider.py</code> <pre><code>@paramorator\ndef asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | None = None,\n) -&gt; AsyncProvider[P, R]:\n    \"\"\"Create a provider from the given async iterator function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_iterator_yield_type(func, sync=False)\n    norm_dependencies = get_callable_dependencies(func, dependencies)\n    return AsyncProvider(\n        (\n            injector.asynccontextmanager(func, dependencies=norm_dependencies)\n            if norm_dependencies\n            else _asynccontextmanager(func)\n        ),\n        cast(type[R], provides),\n        set(norm_dependencies.values()),\n    )\n</code></pre>"},{"location":"reference/#pybooster.provider.function","title":"pybooster.provider.function","text":"<pre><code>function(\n    func: Callable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | None = None\n) -&gt; SyncProvider[P, R]\n</code></pre> <p>Create a provider from the given function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/provider.py</code> <pre><code>@paramorator\ndef function(\n    func: Callable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | None = None,\n) -&gt; SyncProvider[P, R]:\n    \"\"\"Create a provider from the given function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_callable_return_type(func)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Iterator[R]:\n        yield func(*args, **kwargs)\n\n    return iterator(wrapper, provides=provides, dependencies=dependencies)\n</code></pre>"},{"location":"reference/#pybooster.provider.iterator","title":"pybooster.provider.iterator","text":"<pre><code>iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | None = None\n) -&gt; SyncProvider[P, R]\n</code></pre> <p>Create a provider from the given iterator function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>IteratorCallable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/provider.py</code> <pre><code>@paramorator\ndef iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | None = None,\n) -&gt; SyncProvider[P, R]:\n    \"\"\"Create a provider from the given iterator function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_iterator_yield_type(func, sync=True)\n    norm_dependencies = get_callable_dependencies(func, dependencies)\n    return SyncProvider(\n        injector.contextmanager(func, dependencies=norm_dependencies) if norm_dependencies else _contextmanager(func),\n        cast(type[R], provides),\n        set(norm_dependencies.values()),\n    )\n</code></pre>"},{"location":"reference/#pybooster.shared","title":"pybooster.shared","text":""},{"location":"reference/#pybooster.shared.shared","title":"pybooster.shared.shared","text":"<pre><code>shared(\n    cls: type[T] | Sequence, value: T = undefined\n) -&gt; _SharedContext[T]\n</code></pre> <p>Declare that a single value should be shared across all injections of a dependency.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[T] | Sequence</code> <p>The dependency to share.</p> required <code>value</code> <code>T</code> <p>The value to share. If not provided, the dependency will be resolved.</p> <code>undefined</code> Source code in <code>src/pybooster/shared.py</code> <pre><code>def shared(cls: type[T] | Sequence, value: T = undefined) -&gt; _SharedContext[T]:\n    \"\"\"Declare that a single value should be shared across all injections of a dependency.\n\n    Args:\n        cls: The dependency to share.\n        value: The value to share. If not provided, the dependency will be resolved.\n    \"\"\"\n    return _SharedContext(normalize_dependency(cls), value=value)\n</code></pre>"},{"location":"reference/#pybooster.types","title":"pybooster.types","text":""},{"location":"reference/#pybooster.types.AsyncContextManagerCallable","title":"pybooster.types.AsyncContextManagerCallable","text":"<pre><code>AsyncContextManagerCallable = Callable[\n    P, AbstractAsyncContextManager[R]\n]\n</code></pre> <p>A callable that returns an async context manager.</p>"},{"location":"reference/#pybooster.types.AsyncIteratorCallable","title":"pybooster.types.AsyncIteratorCallable","text":"<pre><code>AsyncIteratorCallable = Callable[P, AsyncIterator[R]]\n</code></pre> <p>A callable that returns an async iterator.</p>"},{"location":"reference/#pybooster.types.ContextManagerCallable","title":"pybooster.types.ContextManagerCallable","text":"<pre><code>ContextManagerCallable = Callable[\n    P, AbstractContextManager[R]\n]\n</code></pre> <p>A callable that returns a context manager.</p>"},{"location":"reference/#pybooster.types.Dependencies","title":"pybooster.types.Dependencies","text":"<pre><code>Dependencies = Mapping[str, type | Sequence[type]]\n</code></pre> <p>A mapping of parameter names to their possible type or types.</p>"},{"location":"reference/#pybooster.types.IteratorCallable","title":"pybooster.types.IteratorCallable","text":"<pre><code>IteratorCallable = Callable[P, Iterator[R]]\n</code></pre> <p>A callable that returns an iterator.</p>"},{"location":"reference/#pybooster.types.required","title":"pybooster.types.required","text":"<pre><code>required = make_sentinel_value(__name__, 'required')\n</code></pre> <p>A sentinel object used to indicate that a dependency is required.</p>"},{"location":"reference/#pybooster.types.ProviderMissingError","title":"pybooster.types.ProviderMissingError","text":"<p>               Bases: <code>RuntimeError</code></p> <p>An error raised when a provider is missing.</p>"}]}